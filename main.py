import os
import random
import time
from flask import Flask
from threading import Thread
from dotenv import load_dotenv
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    CallbackContext,
    filters,
)
from huggingface_hub import InferenceClient
from PIL import Image, ImageEnhance, ImageFilter

load_dotenv("token.env")
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
HF_TOKEN = os.getenv("HF_API_KEY")

LORAS = os.getenv("LORAS", "").split(',')

client = InferenceClient("black-forest-labs/FLUX.1-schnell", token=HF_TOKEN)

app = Flask(__name__)

GENERATE, CANCEL = range(2)

total_images_generated = 0
active_users = set()
total_users = set()

@app.route("/")
def home():
    return "Bot is running!"

def run_flask():
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", 5000)))

async def start(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text(
        "‚ú® *Welcome to the AI Image Bot!* ‚ú®\n\n"
        "This bot allows you to generate high-quality AI images based on your prompts.\n\n"
        "Use /help to explore available commands and features. Let's create amazing images together!\n\n"
        "_Start by typing a prompt, and the bot will generate an image based on it._",
        parse_mode="Markdown",
    )

async def help_command(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text(
        "üìú *Available Commands:*\n\n"
        "/start - Start the bot\n"
        "Use this command to get an introduction to the bot and its features.\n\n"
        "/help - View all commands and their usage\n"
        "This will show you a list of available commands and explain their functionality.\n\n"
        "/generate - Generate an AI image based on your prompt\n"
        "Start generating an AI image by providing a prompt. The bot will create an image based on it.\n\n"
        "/cancel - Cancel the ongoing image generation\n"
        "If you're in the middle of generating an image, use this to stop it.\n\n"
        "/stats - View bot statistics (active users, total images generated, etc.)\n"
        "Check the number of active users, generated images, and overall bot stats.\n\n"
        "/about - Learn more about this bot and its features\n"
        "Get information about the bot, its creator, and the technology it uses.\n\n"
        "_You can use /generate to create stunning AI-generated images!_",
        parse_mode="Markdown",
    )

async def about(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text(
        "ü§ñ *About This Bot:*\n\n"
        "üîπ *Owner:* Your Name\n"
        "The bot was created to generate AI images based on text prompts.\n\n"
        "üîπ *Purpose:* Generate high-quality AI images based on prompts.\n"
        "This bot allows users to describe an image and get a high-quality version generated by AI.\n\n"
        "üîπ *Technology:* Uses advanced AI models (like FLUX.1) and Stable Diffusion to create images.\n"
        "This bot uses the Hugging Face API to power the AI model for generating images from text prompts.\n\n"
        "üîπ *Features:* Image generation based on text prompts, enhancements, and LoRAs.\n"
        "The bot is designed to enrich creativity by applying additional LoRAs (custom models) for better results.\n\n"
        "Start by typing a prompt, and let the bot generate art for you!",
        parse_mode="Markdown",
    )

async def stats(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text(
        "üìä *Bot Statistics:*\n\n"
        f"üë• *Active Users:* {len(active_users)}\n"
        f"üñºÔ∏è *Images Generated:* {total_images_generated}\n"
        f"üåç *Total Users:* {len(total_users)}\n"
        "üîß *Version:* 1.0.0\n\n"
        "_Stay tuned for more updates and features!_",
        parse_mode="Markdown",
    )

async def generate(update: Update, context: CallbackContext) -> int:
    user_id = update.effective_user.id
    active_users.add(user_id)
    total_users.add(user_id)

    await update.message.reply_text("‚ú® Send me a prompt to generate an image:")
    return GENERATE

async def handle_prompt(update: Update, context: CallbackContext) -> int:
    global total_images_generated
    prompt = update.message.text

    try:
        with open("variations.txt", "r") as file:
            variations = file.readlines()
    except FileNotFoundError:
        variations = []
        await update.message.reply_text(
            "‚ö†Ô∏è *Variation file not found, proceeding without variations.*",
            parse_mode="Markdown",
        )

    if variations:
        variation = random.choice(variations).strip()
        full_prompt = f"{prompt} {variation}"
    else:
        full_prompt = prompt

    seed = random.randint(0, 2**32 - 1)
    await update.message.reply_text(
        f"üé® *Generating your image...*\n"
        f"_Prompt:_ {full_prompt}\n"
        f"_Seed:_ {seed}\n"
        "Please wait ‚è≥",
        parse_mode="Markdown",
    )

    try:
        start_time = time.time()

        image = client.text_to_image(full_prompt, seed=seed)

        new_size = (2160, 3840)
        image = image.resize(new_size, Image.Resampling.LANCZOS)

        enhancer_sharpness = ImageEnhance.Sharpness(image)
        image = enhancer_sharpness.enhance(2.0)

        enhancer_brightness = ImageEnhance.Brightness(image)
        image = enhancer_brightness.enhance(1.2)

        enhancer_contrast = ImageEnhance.Contrast(image)
        image = enhancer_contrast.enhance(1.5)

        enhancer_color = ImageEnhance.Color(image)
        image = enhancer_color.enhance(1.3)

        image = image.filter(ImageFilter.GaussianBlur(radius=0.5))

        for lora in LORAS:
            if lora.strip():
                print(f"Applying LoRA: {lora.strip()}")
                image = client.apply_lora(image, lora.strip())

        image_path = f"generated_image_{random.randint(1000, 9999)}.png"
        image.save(image_path, format="PNG", optimize=False)

        total_images_generated += 1

        generation_time = time.time() - start_time

        await update.message.reply_document(
            document=open(image_path, "rb"),
            filename=f"{image_path}",
            caption=f"üé® *Prompt:* {full_prompt}\n"
                    f"üïí *Time taken to generate:* {generation_time:.2f} seconds\n"
                    f"_Your AI-generated image is ready!_",
            parse_mode="Markdown",
        )

        os.remove(image_path)

    except Exception as e:
        await update.message.reply_text(
            f"‚ùå *Failed to generate the image.*\n"
            f"Error: {str(e)}",
            parse_mode="Markdown",
        )

    active_users.discard(update.effective_user.id)
    return ConversationHandler.END

async def cancel(update: Update, context: CallbackContext) -> int:
    active_users.discard(update.effective_user.id)
    await update.message.reply_text("‚ö†Ô∏è Image generation canceled.")
    return ConversationHandler.END

def main():
    flask_thread = Thread(target=run_flask)
    flask_thread.daemon = True
    flask_thread.start()

    application = ApplicationBuilder().token(BOT_TOKEN).build()

    start_handler = CommandHandler("start", start)
    help_handler = CommandHandler("help", help_command)
    about_handler = CommandHandler("about", about)
    stats_handler = CommandHandler("stats", stats)

    generate_handler = ConversationHandler(
        entry_points=[CommandHandler("generate", generate)],
        states={
            GENERATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_prompt)]
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    application.add_handlers(
        [start_handler, help_handler, about_handler, stats_handler, generate_handler]
    )

    application.run_polling()

if __name__ == "__main__":
    main()
